<?php

/**
 * @file
 * Code for the Project issue tracking module.
 */

/// Default age in days of issues to auto close.
define('PROJECT_ISSUE_AUTO_CLOSE_DAYS', 14);
/// Project issue state = fixed.
define('PROJECT_ISSUE_STATE_FIXED', 2);
/// Project issue state = closed.
define('PROJECT_ISSUE_STATE_CLOSED', 7);

/**
 * Project issue notification level: No notification emails.
 */
define('PROJECT_ISSUE_NOTIFICATION_NONE', 0);

/**
 * Project issue notification level: Own/flagged issues.
 */
define('PROJECT_ISSUE_NOTIFICATION_OWN', 1);

/**
 * Project issue notification level: All issues.
 */
define('PROJECT_ISSUE_NOTIFICATION_ALL', 2);

/**
 * Project issue notification e-mail contains the full issue history.
 */
define('PROJECT_ISSUE_MAIL_BODY_FULL_HISTORY', 0);

/**
 * Project issue notification e-mail only contains new content.
 */
define('PROJECT_ISSUE_MAIL_BODY_NEW_CONTENT', 1);

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function project_issue_ctools_plugin_directory($module, $plugin) {
  if ($module == 'sampler') {
    switch ($plugin) {
      case 'metric':
        return 'metrics';
    }
  }
  if ($module == 'entityreference') {
    return 'plugins/entityreference_' . $plugin;
  }
}

function project_issue_menu() {
  $items = array();

  $includes = drupal_get_path('module', 'project_issue') . '/includes';

  // Project issue notification.
  $items['project/issues/subscribe-mail/%project'] = array(
    'title' => 'Subscribe',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_notification_project_form', 3),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('auth'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/notification.inc',
  );
  $items['user/%user/project-issue'] = array(
    'title' => 'Notifications',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_notification_user_form', 1),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/notification.inc',
  );
  $items['user/%user/project-issue/delete/%project'] = array(
    'page callback' => 'project_issue_notification_user_delete',
    'page arguments' => array(1, 4),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'includes/notification.inc',
  );

  // Administrative pages
  $items['admin/project/project-issue-settings'] = array(
    'title' => 'Project issue settings',
    'description' => 'Specify where attachments to issues should be stored on your site, and what filename extensions should be allowed.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_settings_form'),
    'access arguments' => array('administer projects'),
    'weight' => 1,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/admin.settings.inc',
  );

  // Autocomplete paths.

  // Autocomplete a comma-separated list of projects that have issues enabled.
  $items['project/autocomplete/issue/project'] = array(
    'page callback' => 'project_issue_autocomplete_issue_project',
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete a comma-separated list of projects from all issues a user
  // has either submitted or commented on.
  $items['project/autocomplete/issue/user/%'] = array(
    'page callback' => 'project_issue_autocomplete_user_issue_project',
    'page arguments' => array(4, 5),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete a comma-separated list of projects a user owns.
  $items['project/autocomplete/issue/owner/%'] = array(
    'page callback' => 'project_issue_autocomplete_project_user',
    'page arguments' => array(4, 5),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete an issue nid from a user entered node ID or issue title.
  $items['project/autocomplete/issues/nodereference'] = array(
    'page callback' => 'project_issue_autocomplete_issues_nodereference',
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Adding a project_issue node with the parent project specified in the URL.
  foreach (project_issue_issue_node_types() as $issue_type) {
    $type_url_str = str_replace('_', '-', $issue_type);
    $items['node/add/' . $type_url_str . '/%project'] = array(
      'page callback' => 'project_issue_node_add',
      'page arguments' => array($issue_type, 3),
      'access callback' => 'node_access',
      'access arguments' => array('create', $issue_type),
      'file' => 'includes/issue_node_add.inc',
      'type' => MENU_CALLBACK,
    );
  }

  return $items;
}

/**
 * Implementation of hook_menu_alter().
 *
 * A project_issue node requires a parent project, and also that a "component"
 * of that project is specified.  In order to have the pull-down for the
 * component be properly populated, we hook 'node/add/project-issue' and
 * have the user select a project there, and then a form on
 * 'node/add/project-issue/<projectname>' has the component widget properly
 * constructed.
 */
function project_issue_menu_alter(&$items) {
  foreach (project_issue_issue_node_types() as $issue_type) {
    $type_url_str = str_replace('_', '-', $issue_type);
    $items['node/add/' . $type_url_str]['page callback'] = 'drupal_get_form';
    $items['node/add/' . $type_url_str]['page arguments'] = array('project_issue_pick_project_form', $issue_type);
    $items['node/add/' . $type_url_str]['file'] = 'issue_node_add.inc';
    $items['node/add/' . $type_url_str]['file path'] = drupal_get_path('module', 'project_issue') . '/includes';
  }
}

/**
 * Determine access to a given type of menu item.
 *
 * @param $type
 *   Type of menu item to check access for, can be 'any' if the current user
 *   can access any issues, or 'auth' if the current user is authenticated and
 *   can accses any issues.
 */
function project_issue_menu_access($type) {
  global $user;
  if ($type == 'auth' && empty($user->uid)) {
    return FALSE;
  }
  return user_access('access content');
}

/**
 * Implementation of hook_theme().
 */
function project_issue_theme() {
  return array(
    'project_issue_issue_link' => array(
      'template' => 'theme/project-issue-issue-link',
      'variables' => array(
        'node' => NULL,
        'comment_id' => NULL,
        'comment_number' => NULL,
        'include_assigned' => FALSE,
      ),
    ),
    'project_issue_issue_update_link' => array(
      'template' => 'theme/project-issue-issue-update-link',
      'variables' => array(
        'node' => NULL,
      ),
    ),
    'project_issue_issue_cockpit' => array(
      'template' => 'theme/project-issue-issue-cockpit',
      'file' => 'includes/issue_cockpit.inc',
      'variables' => array(
        'node' => NULL,
      ),
    ),
    'project_issue_notification_projects_table' => array(
      'file' => 'includes/notification.inc',
      'render element' => 'element',
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function project_issue_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'project_issue') . '/views',
  );
}

function project_issue_form_project_issue_issue_cockpit_searchbox_alter(&$form) {
  // Since we're using a GET #action for this searchbox, unset the FAPI
  // cruft we don't want to see in the URL.
  unset($form['form_build_id']);
  unset($form['form_id']);
  unset($form['form_token']);
}

/**
 * Implements hook_node_presave().
 *
 * Adjust timestamps when running import code.
 */
function project_issue_node_presave($node) {
  if (isset($node->_project_issue_changed_timestamp)) {
    $node->changed = $node->_project_issue_changed_timestamp;
    $node->timestamp = $node->_project_issue_changed_timestamp;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Project issue adjustments to the field edit form.
 *
 * Some of the fields implemented by project issue have certain settings that
 * the module depends on, so force those here.
 */
function project_issue_form_field_ui_field_edit_form_alter(&$form) {
  switch ($form['#field']['field_name']) {
    case 'field_project_has_issue_queue':
      $form['field']['#access'] = FALSE;
      $form['instance']['widget']['#access'] = FALSE;
      $form['instance']['required']['#value'] = FALSE;
      $form['instance']['required']['#access'] = FALSE;
      break;
    case 'field_issue_changes':
      $form['field']['#access'] = FALSE;
      $form['instance']['widget']['#access'] = FALSE;
      $form['instance']['default_value_widget']['#access'] = FALSE;
      $form['instance']['required']['#value'] = TRUE;
      $form['instance']['required']['#access'] = FALSE;
      break;
  }
}

/**
 * Implements hook_permission().
 */
function project_issue_permission() {
  return array(
    'assign and be assigned project issues' => array(
      'title' => t('Assign and be assigned project issues'),
      'description' => t('Allow users to assign issues to other users that have been granted this same permission.')
    ),
    'access issue statistics' => array(
      'title' => t('View project-level issue statistics'),
      'description' => t('Allow users to view project-level statistical data regarding issues.'),
    ),
  );
}

function project_issue_access($op, $node, $account) {

  if (user_access('administer projects', $account)) {
    return TRUE;
  }
  switch ($op) {
    case 'create':
      return user_access('create project issues', $account);

    case 'update':
      if (user_access('edit any project issues') || (user_access('edit own project issues', $account) && $node->uid == $account->uid)) {
        return TRUE;
      }
      break;

    case 'delete':
      // Admin case already handled, no one else should be able to delete.
      break;
  }
}

/**
 * Implement hook_project_permission_info()
 */
function project_issue_project_permission_info($project = NULL) {
  return array(
    'maintain issues' => array(
      'title' => t('Maintain issues'),
      'description' => t('Allows a user to assign issues to other issue maintainers for this project.'),
    ),
  );
}

/**
 * Implement hook_project_maintainer_save()
 */
function project_issue_project_maintainer_save($nid, $uid, $permissions = array()) {
  db_merge('project_issue_project_maintainer')
    ->key(array('nid' => $nid, 'uid' => $uid))
    ->fields(array(
      'maintain_issues' => $permissions['maintain issues']
    ))
    ->execute();
}

/**
 * Implement hook_project_maintainer_remove()
 */
function project_issue_project_maintainer_remove($nid, $uid) {
  db_query("DELETE FROM {project_issue_project_maintainer} WHERE nid = :nid and uid = :uid", array(':nid' => $nid, ':uid' => $uid));
}

/**
 * Implement hook_project_maintainer_project_load().
 */
function project_issue_project_maintainer_project_load($nid, &$maintainers) {
  $result = db_query('SELECT u.name, pipm.* FROM {project_issue_project_maintainer} pipm INNER JOIN {users} u ON pipm.uid = u.uid WHERE pipm.nid = :nid ORDER BY u.name', array(':nid' => $nid));
  foreach ($result as $maintainer) {
    if (empty($maintainers[$maintainer->uid])) {
      $maintainers[$maintainer->uid]['name'] = $maintainer->name;
    }
    $maintainers[$maintainer->uid]['permissions']['maintain issues'] = $maintainer->maintain_issues;
  }
}

/**
 * Get the possible issue categories.
 */
function project_issue_categories($plural = FALSE) {
  if ($plural) {
    return array(
      1 => t('Bug reports'),
      2 => t('Tasks'),
      3 => t('Feature requests'),
      4 => t('Support requests'),
    );
  }
  else {
    return array(
      1 => t('Bug report'),
      2 => t('Task'),
      3 => t('Feature request'),
      4 => t('Support request'),
    );
  }
}

/**
 * Loads per-user account settings for project issue notifications.
 *
 * @param $account
 *   A user account object to attach project issue notification settings to.
 *   Required properties:
 *   - uid: The ID of the user account.
 *   Attached properties:
 *   - project_issue_notification: An associative array containing:
 *     - level: An integer denoting the user's global issue notification level:
 *       - PROJECT_ISSUE_NOTIFICATION_NONE
 *       - PROJECT_ISSUE_NOTIFICATION_OWN
 *       - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_user_settings_load_multiple()
 */
function project_issue_notification_user_settings_load(&$account) {
  $preferences = project_issue_notification_user_settings_load_multiple(array($account->uid));
  $account->project_issue_notification = $preferences[$account->uid];
}

/**
 * Loads per-account issue notifications preferences for a set of users.
 *
 * @param array $uids
 *   Array of user IDs to load preferences for.
 *
 * @return array
 *   An array of associative preference arrays indexed by uid.
 *
 * @see project_issue_notification_user_settings_load()
 */
function project_issue_notification_user_settings_load_multiple($uids) {
  // Setup defaults.
  $defaults = array(
    'level' => PROJECT_ISSUE_NOTIFICATION_NONE,
    'mail_body' => PROJECT_ISSUE_MAIL_BODY_FULL_HISTORY,
    'mail_subject_project' => TRUE,
    'mail_subject_category' => TRUE,
  );
  $user_settings = array();
  $result = db_query('SELECT uid, level, mail_body, mail_subject_project, mail_subject_category FROM {project_issue_notification_global} WHERE uid IN (:uids)', array(':uids' => $uids))->fetchAll(PDO::FETCH_ASSOC);
  foreach ($result as $settings) {
    $uid = $settings['uid'];
    unset($settings['uid']);
    $user_settings[$uid] = array_merge($defaults, $settings);
  }
  // Fill in defaults for any users that are still missing their preferences.
  $missing_uids = array_diff($uids, array_keys($user_settings));
  foreach ($missing_uids as $uid) {
    $user_settings[$uid] = $defaults;
  }
  return $user_settings;
}

/**
 * Saves per-user account settings for project issue notification.
 *
 * @param $account
 *   A user account object containing at least the properties:
 *   - uid: The ID of the user account.
 *   - project_issue_notification: An associative array containing:
 *     - level: An integer denoting the user's global issue notification level.
 *       - PROJECT_ISSUE_NOTIFICATION_NONE
 *       - PROJECT_ISSUE_NOTIFICATION_OWN
 *       - PROJECT_ISSUE_NOTIFICATION_ALL
 *     - mail_body: An integer denoting the user's preference for e-mail bodies:
 *       - PROJECT_ISSUE_MAIL_BODY_FULL_HISTORY
 *       - PROJECT_ISSUE_MAIL_BODY_NEW_CONTENT
 *     - mail_subject_category: A Boolean indicating whether the user wants the
 *       issue category (bug, feature, etc) in the subject of e-mails.
 *     - mail_subject_project: A Boolean indicating whether the user wants the
 *       project name in the subject of e-mails.
 *
 * @see project_issue_notification_user_settings_load()
 */
function project_issue_notification_user_settings_save($account) {
  db_merge('project_issue_notification_global')
    ->key(array('uid' => $account->uid))
    ->fields(array(
      'level' => $account->project_issue_notification['level'],
      'mail_body' => $account->project_issue_notification['mail_body'],
      'mail_subject_category' => $account->project_issue_notification['mail_subject_category'],
      'mail_subject_project' => $account->project_issue_notification['mail_subject_project'],
    ))
    ->execute();
}

/**
 * Loads the project issue notification settings for a user account.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 *
 * @return
 *   An integer denoting the user's project issue notification level:
 *   - PROJECT_ISSUE_NOTIFICATION_NONE
 *   - PROJECT_ISSUE_NOTIFICATION_OWN
 *   - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_project_setting_save()
 */
function project_issue_notification_project_setting_load($uid, $nid) {
  $level = db_query('SELECT level FROM {project_issue_notification_project} WHERE uid = :uid AND nid = :nid', array(
    ':uid' => $uid,
    ':nid' => $nid,
  ))->fetchField();
  return ($level !== FALSE ? $level : PROJECT_ISSUE_NOTIFICATION_NONE);
}

/**
 * Saves project notification settings for a user account.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 * @param $level
 *   An integer denoting the user's project issue notification level:
 *   - PROJECT_ISSUE_NOTIFICATION_NONE
 *   - PROJECT_ISSUE_NOTIFICATION_OWN
 *   - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_project_setting_load()
 */
function project_issue_notification_project_setting_save($uid, $nid, $level) {
  db_merge('project_issue_notification_project')
    ->key(array(
      'uid' => $uid,
      'nid' => $nid,
    ))
    ->fields(array(
      'level' => $level,
    ))
    ->execute();
}

/**
 * Removes the project notification settings for a given user and project.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 */
function project_issue_notification_project_setting_delete($uid, $nid) {
  db_delete('project_issue_notification_project')
    ->condition('uid', $uid)
    ->condition('nid', $nid)
    ->execute();
}

/**
 * Implements hook_user_cancel().
 */
function project_issue_user_cancel($edit, $account, $method) {
  return project_issue_user_delete($account);
}

/**
 * Implements hook_user_delete().
 */
function project_issue_user_delete($account) {
  // Delete project maintainer assignments and all e-mail notification settings
  // in case a user account is deleted or disabled/banned.
  db_delete('project_issue_notification_global')->condition('uid', $account->uid)->execute();
  db_delete('project_issue_notification_project')->condition('uid', $account->uid)->execute();
  db_delete('project_issue_project_maintainer')->condition('uid', $account->uid)->execute();
}

/**
 * Implementation of hook_mail(). (stub function)
 */
function project_issue_mail($key, &$message, $params) {
  module_load_include('inc', 'project_issue', 'includes/mail');
  return _project_issue_mail($key, $message, $params);
}

/**
 * Implements hook_entity_info_alter().
 */
function project_issue_entity_info_alter(&$info) {
  $info['node']['view modes']['issuemetadata'] = array(
    'label' => t('Project issue meta data table'),
    'custom settings' => TRUE,
  );
}

/**
 * Return the issue metadata fields for a given issue node.
 *
 * This relies on the 'issuemetadata' view mode for issue nodes.
 *
 * @param stdClass $issue
 *   A fully-loaded issue node object to build metadata for.
 *
 * @return array
 *   An array of issue metadata fields, suitable for use with drupal_render().
 *
 * @see drupal_render()
 * @see project_issue_entity_info_alter()
 */
function project_issue_metadata_build($issue) {
  if (empty($issue) || !project_issue_node_is_issue($issue)) {
    return array();
  }
  // Mostly, we just want the full node_view() using the right view mode.
  $build = node_view($issue, 'issuemetadata');
  // However, we need to unset/hide some things usually injected into nodes
  // that isn't issue metadata itself.
  unset($build['#theme']);
  $build['links']['#access'] = FALSE;
  $build['#contextual_links']['#access'] = FALSE;
  return $build;
}

/**
 * Return the table of projects for a user (the header for "My projects").
 *
 * @param $project_count
 *   Reference to a variable that will hold the number of projects owned by
 *   the user.
 *
 * @return
 *   String containing the HTML for the table of projects owned by the user.
 */
function project_issue_my_projects_table(&$project_count) {
  global $user;
  $output = '';
  $uid = 0;
  // Initialize to 0 in case we return early on an error.
  $display = views_get_page_view();
  if (!empty($display->view->argument['uid'])) {
    $uid = $display->view->argument['uid']->get_value();
  }

  if (empty($uid)) {
    return;
  }

  $add_project_link = '';
  if (node_access('create', 'project_project')) {
    $add_project_link = t('<a href="@add_project_url">Add a new project</a>', array('@add_project_url' => url('node/add/project-project')));
  }

  $header = array(
    array('data' => t('Project'), 'field' => 'n.title', 'sort' => 'asc'),
    array(
      'data' => t('Last issue update'),
      'field' => 'max_issue_changed',
      'class' => 'project-issue-updated',
    ),
    array(
      'data' => t('Open issues'),
      'field' => 'count',
      'class' => 'project-issues',
    ),
    array('data' => t('Issue links'), 'class' => 'project-issue-links'),
  );
  $default_states = implode(',', project_issue_default_states());
  $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, COUNT(ni.nid) AS count, MAX(ni.changed) AS max_issue_changed FROM {node} n LEFT JOIN {project_issues} pi ON n.nid = pi.pid AND pi.sid IN ($default_states) LEFT JOIN {node} ni ON ni.nid = pi.nid AND ni.status = 1 WHERE n.type = 'project_project' AND n.status = 1 AND n.uid = %d GROUP BY n.nid, n.title") . tablesort_sql($header), $uid);

  $any_admin = FALSE;
  $any_sandbox_admin = FALSE;
  $projects = array();
  $sandbox_projects = array();

  while ($node = db_fetch_object($result)) {
    $project_count++;
    $node_obj = node_load($node->nid);
    $node->is_admin = node_access('update', $node_obj);
    $node->project['uri'] = $node_obj->project['uri'];
    $node->project_issue['issues'] = $node_obj->project_issue['issues'];
    $node->project_release['releases'] = isset($node_obj->project_release['releases']) ? $node_obj->project_release['releases'] : 0;
    if (!empty($node_obj->project['sandbox'])) {
      $sandbox_projects[] = $node;
      if ($node->is_admin) {
        $any_sandbox_admin = TRUE;
      }
    }
    else {
      $projects[] = $node;
      if ($node->is_admin) {
        $any_admin = TRUE;
      }
    }
  }

  // If there are no projects, just return a message about that, not a table.
  if (empty($projects) && empty($sandbox_projects)) {
    // If it's the current user, use a different message.
    if ($uid == $user->uid) {
      // If the user can create projects, add a link to do so in the message.
      if (!empty($add_project_link)) {
        $output = t('You have no projects. !add_project_link.', array('!add_project_link' => $add_project_link));
      }
      else {
        $output = t('You have no projects.');
      }
    }
    else {
      // In this case, it's weird and pointless to have an add project link.
      $output = t('This user has no projects.');
    }
    return $output;
  }

  if (!empty($projects)) {
    $output .= _project_issue_my_projects_build_table($projects, $header, $any_admin, $add_project_link);
  }

  if (!empty($sandbox_projects)) {
    $account = user_load($uid);
    $title = t('Sandbox projects by @user', array('@user' => $account->name));
    if (empty($projects)) {
      // If there are no real projects, we need to clobber the existing page
      // title or we'll get duplicate and contradictory headings.
      drupal_set_title($title);
    }
    else {
      // Evil hard-coded markup.  @see http://drupal.org/node/1028140
      $output .= '<h2 id="sandboxes">' . $title . '</h2>';
    }
    $output .= _project_issue_my_projects_build_table($sandbox_projects, $header, $any_sandbox_admin, $add_project_link, TRUE);
  }

  return $output;
}

/**
 * Private helper function to construct a table of projects.
 *
 * This is used for building the table(s) at the top of the 'My projects' page.
 *
 * @param array $projects
 *   Array of projects to include in the table.
 * @param array $header
 *   The header definition to use for the table.
 * @param boolean any_admin
 *   Is the current user a maintainer admin on any of the projects?
 * @param string $add_project_link
 *   The markup for a link to add new projects (if allowed) or an empty string.
 * @param boolean $is_sandbox
 *   Is this an array of sandbox projects or not.
 *
 * @return string
 *   The fully rendered markup for the table of projects.
 *
 * @see project_issue_my_projects_table()
 */
function _project_issue_my_projects_build_table($projects, $header, $any_admin, $add_project_link, $is_sandbox = FALSE) {
  $rows = array();
  foreach ($projects as $node) {
    $issue_links = array(
      array(
        'title' => t('View'),
        'href' => 'project/issues/' . $node->project['uri'],
      ),
      array(
        'title' => t('Search'),
        'href' => 'project/issues/search/' . $node->project['uri'],
      ),
      array(
        'title' => t('Create'),
        'href' => 'node/add/project-issue/' . $node->project['uri'],
      ),
    );
    if ($node->is_admin) {
      $project_links = array(
        array(
          'title' => t('Edit'),
          'href' => "node/$node->nid/edit",
        ),
      );
      if (module_exists('project_release') && $node->project_release['releases']) {
        $project_links[] = array(
          'title' => t('Add release'),
          'href' => "node/add/project-release/$node->nid",
        );
      }
    }
    if ($node->project_issue['issues']) {
      $row = array(
        array(
          'data' => l($node->title, "node/$node->nid"),
          'class' => 'project-name',
        ),
        array(
          'data' => $node->max_issue_changed ? format_interval(time() - $node->max_issue_changed, 2) : t('n/a'),
          'class' => 'project-issue-updated',
        ),
        array(
          'data' => $node->count,
          'class' => 'project-issues',
        ),
        array(
          'data' => theme('links', $issue_links),
          'class' => 'project-issue-links',
        ),
      );
    }
    else {
      $row = array(
        array(
          'data' => l($node->title, "node/$node->nid"),
          'class' => 'project-name',
        ),
        array(
          'data' => t('Issue tracking is disabled.'),
          'colspan' => $node->is_admin ? 2 : 3,
        ),
      );
      if ($node->is_admin) {
        $row[] = array(
          'data' => l(t('Enable'), "node/$node->nid/edit/issues", array('query' => drupal_get_destination())),
          'class' => 'project-issue-links',
        );
      }
    }
    if ($node->is_admin) {
      $row[] = array(
        'data' => theme('links', $project_links),
        'class' => 'project-project-links',
      );
    }
    elseif ($any_admin) {
      $row[] = array();
    }

    $rows[] = $row;
  }

  if (!empty($add_project_link)) {
    $rows[] = array(
      array(
        'data' => $add_project_link,
        'colspan' => $any_admin ? 5 : 4,
      ),
    );
  }

  if ($any_admin) {
    $header[] = array('data' => t('Project links'), 'class' => 'project-project-links');
  }

  $class = 'projects';
  if ($is_sandbox) {
    $class .= ' sandbox';
  }
  return theme('table', $header, $rows, array('class' => $class));
}

/**
 * Page callback function for the "Issues" subtab at the site-wide search page.
 */
function project_issue_search_page() {
  $view_info = variable_get('project_issue_search_issues_view', 'project_issue_search_all:default');
  $view_parts = explode(':', $view_info);
  $view = views_get_view($view_parts[0]);
  $view->override_path = 'search/issues';
  $output .=  $view->preview($view_parts[1]);
  return $output;
}

/**
 * Submit handler to adjust project issue metadata when comments are mass edited.
 */
function project_issue_comment_mass_update($form_id, $form_values) {
  // This filters non-numeric values, then empty values.
  $cids = array_filter(array_filter($form_values['comments'], 'is_numeric'));
  $issue_comments = db_query("SELECT n.nid, c.cid FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE c.cid IN (" . implode(', ', $cids) . ") AND n.type = 'project_issue'");
  while ($issue_comment = db_fetch_object($issue_comments)) {
    project_issue_update_by_comment($issue_comment, 'update');
  }
}

/**
 * Set the breadcrumb trail for project issues and issue followups.
 *
 * Since the comment form and a full node view of an issue can appear
 * on both full issue pages and comment reply pages, this function checks
 * to see which page is being loaded, and sets the breadcrumb appropriately.
 *
 * @param $node
 *   The issue node object.
 * @param $project
 *   The project node object.
 */
function project_issue_set_breadcrumb($node, $project) {
  $extra = array();
  $extra[] = l($project->title, 'node/' . $project->nid);
  $extra[] = l(t('Issues'), 'project/issues/' . $project->project['uri']);
  // Add the issue title if we're on a comment reply page.
  if (project_issue_is_comment_reply() || project_issue_is_comment_edit()) {
    $extra[] = l($node->title, 'node/' . $node->nid);
  }
  project_project_set_breadcrumb($project, $extra);
}

/**
 * @defgroup project_issue_filter Project Issue number to link filter.
 */

/**
 * Template preprocess callback for automatic Project Issue links.
 *
 * @param $node
 *   The issue node object to be linked.
 * @param $comment_id
 *   The comment id to be appended to the link, optional.
 * @param $comment_number
 *   The comment's number, as visible to users, optional.
 * @param $include_assigned
 *   Optional boolean to include the user the issue is assigned to.
 *
 * @ingroup project_issue_filter themeable
 */
function template_preprocess_project_issue_issue_link(&$variables) {
  $node = $variables['node'];
  $comment_id = $variables['comment_id'];
  $comment_number = $variables['comment_number'];
  $include_assigned = $variables['include_assigned'];

  $node_wrapper = entity_metadata_wrapper('node', $node);

  $path = "node/$node->nid";

  // Try to get the value of the assigned variable, if the field does not exist
  // it will just pass over this and leave as null.
  try {
    $assigned = $node_wrapper->field_issue_assigned->value();
    $username = $assigned == NULL ? NULL : $assigned->name;
  }
  catch (Exception $e) {
    $assigned = NULL;
  }

  try {
    $status = $node_wrapper->field_issue_status->value();
    $status_field = field_info_field('field_issue_status');
    $status_str = $status_field['settings']['allowed_values'][$status];
  }
  catch (Exception $e) {
    $status = 0;
    $status_str = t('Unknown');
  }

  $variables['status_id'] = $status;
  $variables['status_label'] = $status_str;

  if (isset($username) && !$include_assigned) {
    // We have an assigned user, but we're not going to print it next to the
    // issue link, so include it in title. l() runs $attributes through
    // drupal_attributes() which escapes the value.
    $attributes = array('title' => t('Status: !status, Assigned to: !username', array('!status' => $status_str, '!username' => $username)));
  }
  else {
    // Just the status.
    $attributes = array('title' => t('Status: !status', array('!status' => $status_str)));
  }

  if (isset($comment_id)) {
    $title = "#$node->nid-$comment_number: $node->title";
    $link = l($title, $path, array('attributes' => $attributes, 'fragment' => "comment-$comment_id"));
  }
  else {
    $title = "#$node->nid: $node->title";
    $link = l($title, $path, array('attributes' => $attributes));
  }
  $variables['link'] = $link;

  $variables['classes_array'][] = 'project-issue-status-info';
  $variables['classes_array'][] = drupal_html_class('project-issue-status-' . $status);

  if ($include_assigned && isset($username)) {
    $variables['assigned_to'] = t('Assigned to: @username', array('@username' => $username));
  }
  else {
    $variables['assigned_to'] = '';
  }
}

/**
 * Template preprocess callback for the 'Update this issue' button/link.
 *
 * @param $node
 *   The issue node object to be updated.
 */
function template_preprocess_project_issue_issue_update_link(&$variables) {
  $node = $variables['node'];

  $variables['classes_array'][] = 'issue-button';
  $variables['update_url'] = url('node/' . $node->nid . '/edit');
  $variables['update_text'] = t('Update this issue');
  $variables['last_update'] = t('Last updated on %date', array('%date' => format_date($node->changed)));
}

/**
 * Implements hook_filter_info().
 *
 * @ingroup project_issue_filter
 */
function project_issue_filter_info() {
  $filters['filter_project_issue_link'] = array(
    'title' => t('Project issue to link filter'),
    'description' => t('Converts references to project issues (in the form of [#12345]) into links. Caching should be disabled if node access control modules are used.'),
    'process callback' => '_project_issue_filter',
    'tips callback' => '_project_issue_filter_tips',
    'cache' => TRUE,
  );
  return $filters;
}


/**
 * Filter tips callback.
 *
 * @ingroup project_issue_filter
 */
function _project_issue_filter_tips($delta, $format, $long = FALSE) {
  if ($long) {
    return t("References to project issues in the form of [#1234] (or [#1234-2] for comments) turn into links automatically, with the title of the issue appended. The status of the issue is shown on hover. If '@' is appended (e.g. [#1234@]), the user the issue is assigned to will also be printed.");
  }
  else {
    return t('Project issue numbers (ex. [#12345]) turn into links automatically.');
  }
}

/**
 * Filter process callback.
 *
 * @ingroup project_issue_filter
 */
function _project_issue_filter($text, $filter, $format) {
  $regex = '(?:(?<!\w)\[#\d+(?:-\d+)?(@)?\](?!\w))|<pre>.*?<\/pre>|<code>.*?<\/code>|<a(?:[^>"\']|"[^"]*"|\'[^\']*\')*>.*?<\/a>';
  $text = preg_replace_callback("/$regex/", 'project_issue_link_filter_callback', $text);
  return $text;
}

/**
 * Callback function used by preg_replace_callback().
 *
 * @ingroup project_issue_filter
 */
function project_issue_link_filter_callback($matches) {
  $parts = array();
  if (preg_match('/^\[#(\d+)(?:-(\d+))?(@)?\]$/', $matches[0], $parts)) {
    $nid = $parts[1];
    $include_assigned = isset($parts[3]);

    // As this should not be changed by other functions,
    // drupal_static should not be used.
    static $entities = array();

    $running = isset($entities[$nid]) ? $entities[$nid] : FALSE;

    if ($running == TRUE) {
      return NULL;
    }
    else {
      $entities[$nid] = TRUE;
      $entity = entity_load('node', array($nid));
      $node = $entity[$nid];
      $entities[$nid] = FALSE;
    }

    if (project_issue_node_is_issue($node) && node_access('view', $node)) {
      // @todo We need to figure out what to do about comments here.
      // @see https://drupal.org/node/1632492
      /*
      if (!empty($parts[2])) {
        // Pull comment id based on the comment number if we have one.
        $comment_number = $parts[2];
        if ($comment_id = db_result(db_query("SELECT pic.cid FROM {project_issue_comments} pic INNER JOIN {comments} c ON pic.cid = c.cid WHERE pic.nid = %d AND pic.comment_number = %d AND c.status = %d", $nid, $comment_number, COMMENT_PUBLISHED))) {
          return theme('project_issue_issue_link', array('node' => $node, 'comment_id' => $comment_id, 'comment_number' => $comment_number, 'include_assigned' => $include_assigned));
        }
      }
      */
      // If we got this far there wasn't a valid comment number, so just link
      // to the node instead.
      return theme('project_issue_issue_link', array('node' => $node, 'include_assigned' => $include_assigned));
    }
  }
  // If we haven't already returned a replacement, return the original text.
  return $matches[0];
}

/**
 * Implementation of hook_requirements().
 *
 * Check for conflicts with:
 *   installed node access control modules,
 *   'access project issues' restrictions,
 *   filters escaping code with higher weight.
 *
 * @ingroup project_issue_filter
 */
function project_issue_requirements($phase) {
  $requirements = array();
  $input_formats = array();
  if ($phase == 'runtime') {

    $grants = module_implements('node_grants');
    $allowed_roles = user_roles(FALSE, 'access project issues');
    $conflict_anonymous = empty($allowed_roles[DRUPAL_ANONYMOUS_RID]);

    foreach (filter_formats() as $format => $input_format) {
      $filters = filter_list_format($format);
      if (isset($filters['project_issue/0'])) {
        if (!empty($grants) && filter_format_allowcache($format)) {
          $requirements[] = array(
            'title' => t('Project Issue to link filter'),
            'value' => t('Some module conflicts were detected.'),
            'description' => t('%issuefilter should not be enabled when a node access control is also in use. Users may be able to see cached titles of project issues they would otherwise not have access to. You should disable this filter in !inputformat input format.', array('%issuefilter' => t('Project Issue to link filter'), '!inputformat' => l($input_format->name, "admin/settings/filters/$format"))),
            'severity' => REQUIREMENT_ERROR,
          );
        }

        if ($conflict_anonymous && filter_format_allowcache($format)) {
          $requirements[] = array(
            'title' => t('Project Issue to link filter'),
            'value' => t('Some security conflicts were detected.'),
            'description' => t('%issuefilter conflicts with project issue access settings. Users who do not have access to all project issues may be able to see titles of project issues. You should disable this filter in !inputformat input format.', array('%issuefilter' => t('Project Issue to link filter'), '!inputformat' => l($input_format->name, "admin/settings/filters/$format"))),
            'severity' => REQUIREMENT_ERROR,
          );
        }

        // Put up an error when some code escaping filter's weight is higher.
        $low_filters = array('filter/0', 'filter/1', 'bbcode/0', 'codefilter/0', 'geshifilter/0');
        foreach ($low_filters as $lfilter) {
          if (isset($filters[$lfilter]) && $filters['project_issue/0']->weight <= $filters[$lfilter]->weight) {
            $description_names['%issuefilter'] = $filters['project_issue/0']->name;
            $description_names['%lowfilter']  = $filters[$lfilter]->name;
            $requirements[] = array(
              'title' => t('Project Issue to link filter'),
              'value' => t('Some filter conflicts were detected.'),
              'description' => t('%issuefilter should come after %lowfilter to prevent loss of layout and highlighting.', $description_names) . ' ' . l(t('Please rearrange the filters.'), "admin/settings/filters/$format/order"),
              'severity' => REQUIREMENT_ERROR,
            );
          }
        }

      }
    }

  }
  return $requirements;
}

function project_issue_form_views_exposed_form_alter(&$form, &$form_state) {
  switch ($form_state['view']->name) {
    case 'project_issue_search_all':
    case 'project_issue_search_project':
    case 'project_issue_user_projects':
      $user_filters = array('assigned', 'submitted', 'participant');
      foreach (element_children($form) as $element) {
        if ($form[$element]['#type'] == 'textfield') {
          if ($form_state['view']->name == 'project_issue_user_projects') {
            $form[$element]['#size'] = 16;
          }
          else {
            $form[$element]['#size'] = 32;
          }
        }
        elseif ($form[$element]['#type'] == 'select' && $form[$element]['#multiple']) {
          $form[$element]['#size'] = 5;
        }
        if (in_array($element, $user_filters)) {
          $form[$element]['#description'] = t('Enter a comma separated list of users.');
        }
      }
      break;
  }
  // Rename the "Apply" button to "Search" on all project_issue_* views.
  if (substr($form_state['view']->name, 0, 14) == 'project_issue_') {
    $form['submit']['#value'] = t('Search');
  }
}

/**
 * Add dynamic css classes to issue tables.
 */
function project_issue_preprocess_views_view_table(&$variables) {
  $view = $variables['view'];
  if ($view->plugin_name == 'project_issue_table') {
    foreach ($view->result as $num => $result) {
      if (isset($result->field_field_issue_status[0])) {
        $variables['row_classes'][$num][] = 'state-' . check_plain($result->field_field_issue_status[0]['raw']['value']);
      }
      if (isset($result->field_field_issue_priority[0])) {
        $variables['row_classes'][$num][] = 'priority-' . check_plain($result->field_field_issue_priority[0]['raw']['value']);
      }
    }
    $variables['classes_array'][] = 'project-issue';
  }
}

/**
 * Generate the links used at the top of query result pages.
 *
 * @param $project_arg
 *   The node ID or project short name (uri) of the project to generate links
 *   for, or NULL if it's a page of site-wide issues.
 *
 * @return
 *   Themed HTML output for the list of links.
 *
 * @see theme_project_issue_query_result_links()
 */
function project_issue_query_result_links($project_arg = NULL) {
  global $user;
  $links = array();

  if (empty($project_arg)) {
    // These are site-wide links, not per-project
    if (node_access('create', 'project_issue')) {
      $links['create'] = array(
        'title' => t('Create a new issue'),
        'href' => "node/add/project-issue",
        'attributes' => array('title' => t('Create a new issue.')),
      );
    }
    else {
      $links['create'] = array(
        'title' => theme('project_issue_create_forbidden'),
        'html'  => TRUE,
      );
    }
    $links['search'] = array(
      'title' => t('Advanced search'),
      'href' => "project/issues/search",
      'attributes' => array('title' => t('Use the advanced search page for finding issues.')),
    );
    if (user_access('access issue statistics')) {
      $links['statistics'] = array(
        'title' => t('Statistics'),
        'href' => "project/issues/statistics",
        'attributes' => array('title' => t('See statistics about issues.')),
      );
    }
  }
  else {
    // We know the project, make project-specific links.
    if (is_numeric($project_arg)) {
      $uri = project_get_uri_from_nid($project_arg);
    }
    else {
      $uri = $project_arg;
    }

    if (node_access('create', 'project_issue')) {
      $links['create'] = array(
        'title' => t('Create a new issue'),
        'href' => "node/add/project-issue/$uri",
        'attributes' => array('title' => t('Create a new issue for @project.', array('@project' => $uri))),
      );
    }
    else {
      $links['create'] = array(
        'title' => theme('project_issue_create_forbidden', $uri),
        'html'  => TRUE,
      );
    }
    $links['search'] = array(
      'title' => t('Advanced search'),
      'href' => "project/issues/search/$uri",
      'attributes' => array('title' => t('Use the advanced search page to find @project issues.', array('@project' => $uri))),
    );
    if (user_access('access issue statistics')) {
      $links['statistics'] = array(
        'title' => t('Statistics'),
        'href' => "project/issues/statistics/$uri",
        'attributes' => array('title' => t('See statistics about @project issues.', array('@project' => $uri))),
      );
    }
    if ($user->uid) {
      $links['subscribe'] = array(
        'title' => t('E-mail notifications'),
        'href' => "project/issues/subscribe-mail/$uri",
        'attributes' => array('title' => t('Manage e-mail notifications about @project issues.', array('@project' => $uri))),
      );
    }
  }
  return theme('project_issue_query_result_links', $links);
}

/**
 * Helper function to return an array of projects that meet a given constraint.
 *
 * @param $constraint
 *   Restrict the list of projects.  Valid options are 'all' (all projects
 *   with issue tracking enabled), 'owner' (all projects owned by a given
 *   user) and 'participant' (all projects from issues that a given user
 *   submitted or commented on.
 * @param $uid
 *   User ID to use for $constraint == 'owner' or 'participant'.
 *
 * @return
 *   Array of project titles, keyed by node ID (nid) that match the given
 *   constraint.
 */
function project_issue_get_projects($constraint = 'all', $uid = NULL) {
  $options = array();
  $join = '';

  $query = new EntityFieldQuery;
  $query
    // Projects are currently restricted to nodes!
    ->entityCondition('entity_type', 'node')

    // That are projects...
    ->entityCondition('bundle', project_project_node_types())

    // Only published projects.
    ->propertyCondition('status', 1)

    // That have issue tracking enabled.
    ->fieldCondition('field_project_has_issue_queue', 'value', 1);

  // Add extra conditions depending on the requested project source.
  switch ($constraint) {
    case 'owner':
      // The given uid must own each project.
      $query->propertyCondition('uid', $uid);
      break;

    case 'participant':
      // @todo This is silly. Maybe we should actually track who participates where...
      $subquery = db_select('node', 'n');
      $subquery->innerJoin('field_data_field_project', 'p', 'n.nid = p.field_project_target_id');
      $subquery->innerJoin('comment', 'c', 'c.nid = p.entity_id AND p.entity_type = :entity_type', array(':entity_type' => 'node'));
      $subquery
        ->condition('n.status', 1)
        ->condition('p.bundle', project_issue_issue_node_types(), 'IN')
        ->condition('c.uid', $uid)
        ->fields('n', array('nid'));
      $query->entityCondition('entity_id', $subquery->execute()->fetchCol());
      break;
  }

  $result = $query
    // Safety limit.
    ->range(0, 200)
    ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    $projects = entity_load('node', $nids);
    foreach ($projects as $project) {
      $options[$project->nid] = $project->title;
    }
  }
  return $options;
}

/**
 * Menu access callback for the project_issue_plugin_access_user_list plugin.
 */
function project_issue_views_user_access($view_name, $display_id, $argument_name) {
  $view = views_get_view($view_name);
  $view->set_display($display_id);
  $view->init_handlers();
  // Find the values for any arguments embedded in the path via '%'.
  $i = 0;
  $common_path = TRUE;
  foreach (explode('/', $view->display_handler->get_option('path')) as $element) {
    if ($element == '%') {
      $view->args[] = arg($i);
    }
    elseif ($element != arg($i)) {
      // Since we are checking a view not on the current path, checking
      // implicit arguments is nonsensical.
      $common_path = FALSE;
    }
    $i++;
  }
  if ($common_path) {
    // Now handle any implicit arguments from the end of the path.
    $num_arguments = count($view->argument);
    while (count($view->args) < $num_arguments) {
      $view->args[] = arg($i);
      $i++;
    }
  }

  $arg_uid = $view->argument[$argument_name]->get_value();
  return !empty($arg_uid);
}

/**
 * Return the views filter identifier for a given project issue vocabulary.
 */
function project_issue_views_filter_identifier($name) {
  return drupal_strtolower(preg_replace('/[^a-zA-Z0-9]/', '_', check_plain($name)));
}

/**
 * Implements hook_block_info().
 */
function project_issue_block_info() {
  return array(
    'issue_cockpit' => array(
      'info' => t('Project: Issue summary'),
      'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
    ),
    'issue-metadata' => array(
      'info' => t('Issue: metadata'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

/**
 * Implements hook_block_configure().
 */
function project_issue_block_configure($delta = '') {
  if ($delta == 'issue_cockpit') {
    $options = array('All' => t('All issues')) + project_issue_categories(TRUE);
    $form['project_issue_cockpit_categories'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Issue categories to display'),
      '#description' => t('Select which categories the block should display a summary of total vs. open issues.'),
      '#default_value' => variable_get('project_issue_cockpit_categories', array('All' => 'All', 1 => 'Bug reports')),
      '#options' => $options,
    );
    return $form;
  }
}

/**
 * Implements hook_block_save().
 */
function project_issue_block_save($delta = '', $edit = array()) {
  if ($delta == 'issue_cockpit') {
    variable_set('project_issue_cockpit_categories', $edit['project_issue_cockpit_categories']);
    // Invalidate the cache for this block since the categories might change.
    cache_clear_all('project_issue_cockpit_block:', 'cache', TRUE);
  }
}

/**
 * Implements hook_block_view().
 */
function project_issue_block_view($delta = '') {
  if ($delta == 'issue_cockpit') {
/*
  @todo D7: how does homebox work now without $edit being passed in here?
    if (isset($edit['homebox'])) {
      if (isset($edit['homebox']->nid)) {
        // Homebox provides stored configuration in $edit.
        $node = node_load($edit['homebox']->nid);
      }
      else {
        return array(
          'subject' => t('Issues for ...'),
          'content' => t('<a href="javascript:void(0)" class="portlet-settings">Configure</a> to select a project.'),
        );
      }
    }
*/
    $node = project_get_project_from_menu();
    if (!empty($node) && !empty($node->field_project_has_issue_queue[LANGUAGE_NONE][0]['value']) && node_access('view', $node)) {
      $cid = 'project_issue_cockpit_block:' . (user_access('access issue statistics') ? '1' : '0') . ':' . $node->nid;
      if (($cache = cache_get($cid))) {
        $block = $cache->data;
      }
      else {
        module_load_include('inc', 'project_issue', 'includes/issue_cockpit');
        $block = array(
          'subject' => t('Issues for @project', array('@project' => $node->title)),
          'content' => theme('project_issue_issue_cockpit', array('node' => $node)),
        );
        cache_set($cid, $block);
      }
      return $block;
    }
  }
  elseif ($delta == 'issue-metadata') {
    $node = menu_get_object();
    if (!empty($node) && project_issue_node_is_issue($node)) {
      $content = project_issue_metadata_build($node);
      $content['update_link'] = array(
        '#attached' => array('css' => array(drupal_get_path('module', 'project_issue') . '/project_issue.css')),
        '#markup' => theme('project_issue_issue_update_link', array('node' => $node)),
        '#weight' => 100,
      );
      return array(
        'subject' => t('Issue status'),
        'content' => $content,
      );
    }
  }
}

/**
 * Adds the project issue follow flag to a node for a user.
 *
 * @param nid
 *   The nid of the issue to flag.
 * @param uid
 *   The user to add the flag for, defaults to the current user.
 */
function project_issue_flag_issue($nid, $uid = NULL) {
  // Flagging an issue only needs to happen if:
  //  - flag is installed
  //  - An authorized user would be associated with the flag.
  //  - The user does not currently have a flag set for the issue.
  $node = node_load($nid);
  $flag_name = flag_tracker_get_tracker_flag($node->type);

  // Special case for during the data migration. We want to enable
  // auto-flagging before we enable the rest of the follow functionality.
  if (empty($flag_name) && module_exists('flag')) {
    $flag_name = variable_get('project_issue_follow_flag_update_6015', FALSE);
  }

  if (!empty($flag_name)) {
    $account = isset($uid) ? user_load($uid) : $GLOBALS['user'];
    if (is_object($account) && $account->uid != 0) {
      $flag = flag_get_flag($flag_name);
      if (!$flag->is_flagged($nid, $account->uid)) {
        $flag->flag('flag', $nid, $account);
      }
    }
  }
}

/**
 * Provide a list of keys Homebox will store.
 */
function project_issue_homebox_block_keys($block) {
  return array('nid');
}

/**
 * Provide an edit form specific to homebox blocks.
 *
 * Allows switching what project is used.
 */
function project_issue_homebox_block_edit_form($block) {
  $form = array();

  $node = node_load($block->nid);
  $form['project_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Project name'),
    '#size' => 20,
    '#autocomplete_path' => 'project/autocomplete/project',
    '#default_value' => empty($node) ? '' : $node->title,
  );
  $form['#validate'][] = 'project_issue_homebox_block_edit_form_validate';

  return $form;
}

/**
 * Validation callback for editing the project issue cockpit block via homebox.
 *
 * Makes sure a valid project title was entered and populates the nid. The nid
 * is automatically saved by homebox if it's in $form_state['values'] so
 * there's no need for a submit callback.
 */
function project_issue_homebox_block_edit_form_validate($form, &$form_state) {
  $nid = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s' AND type = '%s'", $form_state['values']['project_title'], 'project_project'));
  if (empty($nid)) {
    form_set_error('project_title', t('The name you entered (%title) is not a valid project.', array('%title' => $form_state['values']['project_title'])));
  }
  else {
    $form_state['values']['nid'] = $nid;
  }
}

/**
 * Implementation of hook_views_post_render().
 */
function project_issue_views_post_render(&$view, &$output, &$cache) {
  // Commented out because it doesn't work on D7. See https://drupal.org/node/1549760.
  /*
  // Add links to the top of the project_issue views.
  $my_projects_views = variable_get('project_issue_my_projects_views', array('project_issue_user_projects'));
  if (in_array($view->name, $my_projects_views)) {
    // Tack the "my projects" table onto the user projects view.
    if ($view->current_display == 'page_1') {
      $project_count = 0;
      $project_table = project_issue_my_projects_table($project_count);

      // If the user has projects, prepend the table and keep the view output.
      if (!empty($project_count)) {
        $output = $project_table . $output;
      }
      // Otherwise, hide the view output (which will be an empty view with
      // unusable exposed filters) and just use the project table (which will
      // be a message telling the user they have no projects with a link to add
      // a new project if they have permission to do so.
      else {
        $output = $project_table;
      }
    }
  }
  */
  // Add links to the issue queue views.
  $query_link_views = variable_get('project_issue_query_link_views', array('project_issue_all_projects', 'project_issue_project', 'project_issue_search_all', 'project_issue_search_project', 'project_issue_user_issues'));
  if (in_array($view->name, $query_link_views)) {
    if ($view->current_display == 'page_1') {
      $arg = NULL;
      if (isset($view->argument['pid'])) {
        $arg = $view->argument['pid']->get_value();
      }
      $output = project_issue_query_result_links($arg) . $output;
    }
  }
}

/**
 * Preprocess function for the comment theme template.
 *
 * This enforces the 'project_issue_show_comment_signatures' setting.
 */
function project_issue_preprocess_comment(&$variables) {
  if (project_issue_node_type_is_issue($variables['node']->type) && !variable_get('project_issue_show_comment_signatures_' . $variables['node']->type, 0)) {
    $variables['signature'] = '';
  }
}

/**
 * @defgroup project_issue_solr Project Issue ApacheSolr integration
 * @{
 */

/**
 * Implementation of hook_apachesolr_update_index().
 *
 * This adds information about the sandbox vs. full status of the project an
 * issue is assigned to.
 *
 * Beware that this hook is invoked for all nodes, so we should be careful in
 * here to check that we're really dealing with a project_issue node before
 * trying to access any issue-specifc data.
 */
function project_issue_apachesolr_update_index(&$document, $node) {
  if ($node->type == 'project_issue') {
    $project = node_load($node->field_project[LANGUAGE_NONE][0]['value']);
    // The initial "is" is for integer/single.
    $document->is_project_sandbox = ($node->field_project_type[LANGAUGE_NONE][0]['value'] == 'sandbox') ? 1 : 0;
  }
}

/**
 * Implements hook_project_promote_sandbox().
 *
 * Marks all issues attached to the project that they need to be reindexed in
 * Solr now that the 'is_project_sandbox' value will be different.
 */
function project_issue_project_promote_sandbox($project) {
  if (module_exists('apachesolr')) {
    // Using apachesolr_mark_node() would be a performance disaster here with
    // separate queries for each issue. So, we just directly update the DB
    // here with a single query with a subselect and all is well.
    db_query("UPDATE {apachesolr_index_entities_node} SET changed = :changed WHERE nid IN (SELECT entity_id FROM {field_data_field_project} WHERE entity_type = 'node' AND deleted = 0 AND field_project_target_id = :pid", array(':changed' => time(), ':pid' => $project->nid));
  }
}

/**
 * @} End of "defgroup project_issue_solr".
 */

/**
 * Implementation of hook_widget_info().
 */
function project_issue_widget_info() {
  return array(
    // Widget key is limited to 32 chars.
    'project_issue_nodereference_auto' => array(
      'label' => t('Project issue autocomplete text field'),
      'field types' => array('nodereference'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
function project_issue_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'project_issue_nodereference_auto':
      // Get the default process function from hook_elements.
      $default_process = (($info = _element_info('nodereference_autocomplete')) && array_key_exists('#process', $info)) ? $info['#process'] : array();
      // Add our new process element to the default.
      $default_process[] = 'project_issue_nodereference_autocomplete_process';
      return array(
        '#type' => 'nodereference_autocomplete',
        '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
        '#value_callback' => 'project_issue_nodereference_autocomplete_value',
        '#process' => $default_process,
      );
  }
}

/**
 * Returns the value for a project_issue_nodereference autocomplete widget.
 *
 * Finds the node title from the node ID, and returns a value containing both.
 *
 * @see nodereference_autocomplete_value()
 */
function project_issue_nodereference_autocomplete_value($element, $edit = FALSE) {
  $field_key = $element['#columns'][0];
  if (!empty($element['#default_value'][$field_key])) {
    $nid = (int) $element['#default_value'][$field_key];
    $value = '#' . $nid . ': ' . db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $nid));
    return array($field_key => $value);
  }
  return array($field_key => NULL);
}

/**
 * Sets the validation and auto-complete path for the node reference widget.
 *
 * This is an additional process function for the
 * project_issue_nodereference_autocomplete widget. It runs after the
 * default, nodereference_autocomplete_process().
 */
function project_issue_nodereference_autocomplete_process($element, $edit, $form_state, $form) {
  // Get the field key, since the autocomplete element defined by nodereference
  // module just wraps a textfield.
  $field_key  = $element['#columns'][0];

  // Add our custom autocomplete callback.
  $element[$field_key]['#autocomplete_path'] = 'project/autocomplete/issues/nodereference';

  // Unset the default validate.
  $key = array_search('nodereference_autocomplete_validate', $element[$field_key]['#element_validate']);
  if ($key !== FALSE) {
    unset($element[$field_key]['#element_validate'][$key]);
  }

  // Add our custom validate callback.
  $element[$field_key]['#element_validate'][] = 'project_issue_nodereference_autocomplete_validate';

  return $element;
}

/**
 * Validates a project_issue_nodereference_autocomplete element.
 *
 * The field has valid input if it contains a node ID, a node title, or the
 * format supplied by the auto-complete function ('#NID: TITLE'), and if the
 * node is a project issue.
 */
function project_issue_nodereference_autocomplete_validate($element, &$form_state) {
  // Get field information from $element.
  $field_name = $element['#field_name'];
  $type_name = $element['#type_name'];
  $field = content_fields($field_name, $type_name);
  $field_key  = $element['#columns'][0];
  $value = $element['#value'][$field_key];
  $nid = NULL;
  $title = '';

  // Sanity check: we expect $value to be a string or number, so just make sure.
  if (!is_string($value) && !is_numeric($value)) {
    form_error($element[$field_key], t('%name: the value is not a valid issue title or node ID.', array('%name' => $field['widget']['label'])));
    return;
  }

  $value = trim($value);

  // Try to pick the node ID or title out of the information we have.
  // First try to match with auto-complete syntax ('#NID: TITLE') (we will be
  // ignoring the title, however). Make sure we have at least one non-zero
  // digit at the start of the NID.
  if (preg_match('/^#([1-9]\d*):/', $value, $matches)) {
    $nid = $matches[1];
  }
  // Autocomplete syntax didn't work, so see if we have a node ID.
  elseif (is_numeric($value)) {
    $nid = (int) $value;
    if ($nid <= 0) {
      $nid = NULL;
      form_error($element[$field_key], t('%name: Not a valid issue ID.', array('%name' => $field['widget']['label'])));
    }
  }
  // As a last resort, it could be a node title.
  else {
    $title = $value;
  }

  // Now validate either the node ID or the title, making sure it's a
  // published issue node.
  if (!empty($nid)) {
    if (!$nid = db_result(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = 'project_issue' AND n.nid = %d AND status = 1"), $nid))) {
      form_error($element[$field_key], t('%name: Not a valid issue ID.', array('%name' => $field['widget']['label'])));
    }
  }
  elseif (!empty($title)) {
    if (!$nid = db_result(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = 'project_issue' AND n.status = 1 AND n.title = '%s'"), $title))) {
      form_error($element[$field_key], t('%name: the value is not a valid issue ID or title.', array('%name' => $field['widget']['label'])));
    }
  }

  form_set_value($element, $nid, $form_state);
}

/**
 * Implements hook_field_formatter_info().
 *
 * Provides a formatter for nodereference fields that uses
 * theme_project_issue_issue_link().
 */
function project_issue_field_formatter_info() {
  return array(
    'issue_id' => array(
      'label' => t('Issue link styled with status metadata'),
      'field types' => array('entityreference'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'issue_id_assigned' => array(
      'label' => t('Issue link styled with status metadata and assignee'),
      'field types' => array('entityreference'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function project_issue_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();

  $settings = $display['settings'];
  $include_assigned = $display['type'] == 'issue_id_assigned' ? TRUE : FALSE;

  $target_type = $field['settings']['target_type'];
  $target_ids = array();
  foreach ($items as $delta => $item) {
    $target_ids[] = $item['target_id'];
  }
  $entities = entity_load($target_type, $target_ids);

  foreach ($items as $delta => $item) {
    $id = $item['target_id'];
    $output = '';
    if (empty($entities[$id])) {
      // Normally we wouldn't hit this due to entityreference validation, but
      // we might be displaying a stale value that's still pointing at a node
      // that's been deleted or something.
      if ($target_type == 'node') {
        $output = t('Node ID %nid not found', array('%nid' => $id));
      }
      else {
        $output = t('Target ID %id not found', array('%id' => $id));
      }
    }
    elseif ($target_type != 'node') {
      // If our referenced entities aren't nodes, we have to do other things
      // to link to them and they obviously can't be issues so our desired
      // theme formatting won't work.
      $entity = $entities[$id];
      $uri = entity_uri($target_type, $entity);
      $label = entity_label($target_type, $entity);
      $output = l($label, $uri['path']);
    }
    else {
      // From now on, we can assume an existing node.
      $node = $entities[$id];
      if (!project_issue_node_is_issue($node)) {
        // If it's a node but not an issue, just create an unstyled link using
        // the nid as a prefix, and the node title (if it exists).
        if (isset($node->title)) {
          $label = t('#@nid: @title', array('@nid' => $node->nid, '@title' => $node->title));
        }
        else {
          $label = '#' . check_plain($node->nid);
        }
        $output = l($label, 'node/' . $node->nid, array('html' => TRUE));
      }
      else {
        // It's an existing issue, so reuse the theme function for created the
        // styled link (which does coloring based on status, etc).
        $output = theme('project_issue_issue_link', array('node' => $node, 'include_assigned' => $include_assigned));
      }
    }
    $elements[$delta] = array(
      '#markup' => $output,
    );
  }

  return $elements;
}

/**
 * Find the flag name for following issues for this issue type (if any).
 *
 * If the flag tracker module (http://drupal.org/project/flag_tracker) is enabled,
 * project_issue node types can be configured to use a flag for following issues. This
 * function consolidates the checks for if that's all configured, and if so,
 * returns the name of the flag being used for this node type.
 *
 * @param
 *   Node object.
 *
 * @return
 *   The name of the flag being used for following issues of a node type, or '' (an empty
 *   string) if flag_tracker.module isn't enabled or there's no flag configured for
 *   this purpose.
 */
function project_issue_get_follow_flag($node) {
  $flag = '';
  if (module_exists('flag_tracker')) {
    flag_tracker_get_tracker_flag($node->type);
  }
  return $flag;
}

/**
 *  Find all the flags that are being used to track issues.
 *
 *  @return
 *    An array of bundle names that are issues and have a tracker flag set.
 */

function project_issue_get_follow_flags() {
  $issue_types_to_check = project_issue_issue_node_types();
  $tracked_issue_types = array();
  foreach ($issue_types_to_check as $type) {
    if (flag_tracker_get_tracker_flag($type)) {
      $tracked_issue_types[$type] = flag_tracker_get_tracker_flag($type);
    }
  }
  return $tracked_issue_types;
}

/**
 * Implement hook_flag_default_flags().
 */
function project_issue_flag_default_flags() {
  $flags = array();
  $flags['project_issue_follow'] = array(
    'content_type' => 'node',
    'title' => t('Follow'),
    'global' => '0',
    'types' => array(
      0 => 'project_issue',
    ),
    'flag_short' => t('Follow'),
    'flag_long' => '',
    'flag_message' => '',
    'unflag_short' => t('Unfollow'),
    'unflag_long' => '',
    'unflag_message' => '',
    'unflag_denied_text' => '',
    'link_type' => 'toggle',
    'roles' => array(
      'flag' => array(
        0 => 2,
      ),
      'unflag' => array(
        0 => 2,
      ),
    ),
    'show_on_page' => 0,
    'show_on_teaser' => 0,
    'show_on_form' => 0,
    'access_author' => '',
    'i18n' => 0,
    'api_version' => 2,
  );
  return $flags;
}

/**
 * Implements hook_project_node_type_settings().
 */
function project_issue_project_node_type_settings($form) {
  return array(
    '#behavior_label' => t('Used for project issues'),
    'project_issue_show_comment_signatures' => array(
      '#type' => 'checkbox',
      '#title' => t('Display user signatures on issue followups'),
      '#default_value' => variable_get('project_issue_show_comment_signatures_' . $form['#node_type']->type, 0),
      '#description' => t('If selected, user signatures will be appended to the display of issue followups.'),
    ),
    'project_issue_reply_to' => array(
      '#type' => 'textfield',
      '#title' => t('Reply-to address on e-mail notifications'),
      '#default_value' => variable_get('project_issue_reply_to_' . $form['#node_type']->type, variable_get('site_mail', ini_get('sendmail_from'))),
      '#description' => t("All issue notification e-mails will appear from this e-mail address. You can use %project as a placeholder which will be replaced with the machine name for the issue's current project.", array('%project' => '%project')),
    ),
  );
}

/**
 * Determine whether or not a node is an issue.
 *
 * @param $node
 *   A node to check.
 *
 * @return boolean
 *   Is the given node an issue or not?
 */
function project_issue_node_is_issue($node) {
  return project_issue_node_type_is_issue($node->type);
}

/**
 * Determine whether or not a given node type is an issue.
 *
 * Each node type has a setting that determines if it has "issue nature", so
 * we just have to check that setting for the given node type.
 *
 * @param string $node_type
 *   The node type to check.
 *
 * @return boolean
 *   Is the given node type an issue node type or not?
 */
function project_issue_node_type_is_issue($node_type) {
  return variable_get('project_behavior_' . $node_type, FALSE) == 'project_issue';
}

/**
 * Retrieve a list of node types that are considered issues.
 *
 * Each node type has a setting that determines if it has "issue nature", so
 * we just have to check that setting for each node type in the system.
 *
 * @return array
 *   An array of bundle names (aka node type names) that are configured to
 *   have issue nature.
 */
function project_issue_issue_node_types() {
  $issue_node_types = array();
  $node_type_names = node_type_get_names();
  foreach ($node_type_names as $machine_name => $label) {
    if (project_issue_node_type_is_issue($machine_name)) {
      $issue_node_types[] = $machine_name;
    }
  }
  return $issue_node_types;
}

/**
 * Get the list of open states.
 */
function project_issue_open_states() {
  // @todo This is the d.o defaults. Set up the d.o variable and fix this one to
  // be the vanilla defaults!!
  return variable_get('project_issue_open_states', array(1,2,4,8,13,14,15,16));
}

/**
 * Build an array of user IDs to whom an issue may be assigned.
 *
 * @param $issue
 *   A fully loaded issue node, may or may not be created.
 * @param $project
 *   A fully loaded project node.
 * @param $current
 *   The current value of the assigned field, or NULL.
 * @return
 *   An array containing, and keyed by, users IDs to whom an issue may be
 *   assigned.
 */
function project_issue_assigned_choices($issue, $project, $current = NULL) {
  // Setup the array of choices for who the issue is assigned to.
  $assigned = array();
  foreach (module_implements('project_issue_assignees') as $module) {
    $function = "{$module}_project_issue_assignees";
    $assigned += $function($issue, $project, $current);
  }

  // Remove the anonymous user from the list.
  unset($assigned[0]);

  drupal_alter('project_issue_assignees', $assigned, $issue, $project);
  return $assigned;
}

/**
 * Implements hook_project_issue_assignees().
 */
function project_issue_project_issue_assignees($issue, $project, $current) {
  global $user;
  if ($user->uid) {
    if (isset($current) && $user->uid != $current) {
      // Assigned to someone else, add the currently assigned user.
      $assigned[$current] = $current;
    }
    // Always let the person replying assign it to themselves.
    $assigned[$user->uid] = $user->uid;

    // See if the current user is an issue maintainer for the current project.
    $maintainers = $project->project['maintainers'];
    if (!empty($maintainers[$user->uid]['permissions']['maintain issues'])) {
      foreach ($maintainers as $uid => $maintainer) {
        if (!empty($maintainer['permissions']['maintain issues'])) {
          $assigned[$uid] = $uid;
        }
      }
    }
  }

  if (user_access('assign and be assigned project issues')) {
    // All users are included if either anon or auth user has the perm.
    if (db_query("SELECT rid FROM {role_permission} WHERE permission  = :perm AND rid IN(:anon, :auth)", array(':perm' => 'assign and be assigned project issues', ':anon' => DRUPAL_ANONYMOUS_RID, ':auth' => DRUPAL_AUTHENTICATED_RID))->fetchField()) {
      $result = db_query("SELECT uid FROM {users}");
    }
    else {
      $result = db_query("SELECT u.uid FROM {users} u INNER JOIN {users_roles} ur ON u.uid = ur.uid INNER JOIN {role_permission} rp ON rp.rid = ur.rid WHERE rp.permission = :perm", array(':perm' => 'assign and be assigned project issues'));
    }

    foreach ($result as $row) {
      $assigned[$row->uid] = $row->uid;
    }
  }

  return $assigned;
}

/**
 * Implements hook_migrate_api().
 */
function project_issue_migrate_api() {
  $api = array(
    'api' => 2,
  );
  return $api;
}
